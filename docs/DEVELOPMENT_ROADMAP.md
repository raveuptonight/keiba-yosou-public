# 開発ロードマップ・設計方針

## 予想システムの設計思想

### ハイブリッドアプローチ

データ分析（数値）とLLM（言語的知識）の両方の強みを活かす。

```
┌─────────────────────────────────────────────────┐
│                 データ分析層                      │
│  ・スピード指数                                   │
│  ・上がり3F比較                                  │
│  ・馬場差補正                                    │
│  ・コース適性スコア                               │
│  → 客観的な数値データを算出                       │
└─────────────────────┬───────────────────────────┘
                      │ 整形データ
                      ▼
┌─────────────────────────────────────────────────┐
│                   LLM層                          │
│  ・展開予想（逃げ馬、ペース）                      │
│  ・騎手の傾向分析                                │
│  ・ローテーションの影響                           │
│  ・総合的な予想生成                               │
│  → 言語化された知識による判断                     │
└─────────────────────────────────────────────────┘
```

### なぜハイブリッドか

**データ分析だけの問題点**
- 「なぜその馬が強いか」を説明しにくい
- 展開・駆け引きなど数値化しにくい要素がある
- 新馬・データ不足馬への対応が難しい

**LLMだけの問題点**
- 過去データの網羅性に限界
- 再現性が低い（同じ質問でも答えがブレる）
- 計算・統計処理が苦手

**ハイブリッドの強み**
- 数値で裏付けられた客観的分析
- LLMによる言語的解釈と総合判断
- 説明可能な予想（なぜその馬か）

## 特徴量設計

### Phase 3で実装する特徴量

#### 1. スピード指数（基本）

```python
# 基準タイムとの差を指数化
speed_index = (base_time - actual_time) * weight + 100

# 馬場差補正
adjusted_speed = speed_index + track_bias

# クラス補正
class_adjusted = adjusted_speed + class_factor
```

#### 2. 上がり3F分析

```python
# 上がり3F順位（そのレースでの相対位置）
agari_rank = rank_in_race(kohan3f)

# 上がり3F絶対値（馬場補正後）
adjusted_agari = kohan3f - track_agari_bias
```

#### 3. コース適性

```python
# 競馬場×距離×トラック別の成績
course_stats = {
    'wins': count_wins(jyocd, kyori, trackcd),
    'places': count_places(jyocd, kyori, trackcd),
    'runs': count_runs(jyocd, kyori, trackcd),
}
course_score = (wins * 3 + places * 1) / runs
```

#### 4. 展開予測用データ

```python
# 脚質判定（通過順位から）
running_style = classify_style(corner1, corner2, corner3, corner4)
# 逃げ、先行、差し、追込

# 逃げ馬カウント（ペース予測用）
front_runners = count_where(running_style == '逃げ')
```

## LLMプロンプト設計

### 基本構造

```markdown
# レース情報
- {race_name} {distance}m {track_type} {track_condition}
- {course_characteristics}

# 出走馬データ
| 馬番 | 馬名 | 騎手 | 斤量 | スピード指数 | 上がり順位 | 脚質 | コース適性 |
...

# 展開予想
- 逃げ候補: {front_runners}
- 想定ペース: {pace_prediction}

# 過去走サマリー（各馬）
{horse_1_name}:
- 前走: {last_race_summary}
- 2走前: {race_2_summary}
...

# 予想をお願いします
以下の観点で分析してください：
1. 展開予想（ペース、位置取り）
2. 有力馬の分析
3. 穴馬候補
4. 推奨買い目
```

### プロンプトのポイント

1. **データを構造化して渡す** - テーブル形式が見やすい
2. **観点を明示する** - 何を分析してほしいか具体的に
3. **制約を与える** - 「3頭に絞って」など
4. **理由を求める** - 「なぜその馬か説明して」

## 実装の優先順位

### 最小構成（MVP）

1. **DB接続・クエリ** - まず動くものを
2. **出馬表取得** - 今週のレースを表示
3. **過去走取得** - 各馬の直近5走
4. **シンプルプロンプト** - データをそのままLLMへ
5. **予想生成** - とりあえず予想を出す

### 段階的改善

1. スピード指数追加
2. 上がり分析追加
3. コース適性追加
4. 展開予想追加
5. プロンプト改善

## コーディング方針

### 基本原則

- **シンプルに始める** - 最初から完璧を目指さない
- **テスト可能な設計** - 関数は小さく、単一責任
- **設定は外部化** - .envで環境切り替え
- **ログを残す** - デバッグしやすく

### ファイル構成の意図

```
src/
├── db/           # データ層
│   └── queries.py    # SQLは全部ここに集約
├── features/     # 特徴量層
│   └── 各特徴量が独立したファイル
└── predict/      # 予想層
    └── LLM呼び出しと整形
```

- 各層は独立してテスト可能
- 依存方向は db → features → predict の一方向

### エラーハンドリング

```python
# DBエラーは上位で捕捉
try:
    data = fetch_race_data(race_id)
except DatabaseError as e:
    logger.error(f"DB error: {e}")
    raise

# LLMエラーはリトライ
@retry(times=3, delay=1)
def call_claude(prompt):
    ...
```

## 検証・評価

### 回収率の計算

```python
# 単勝回収率
win_return_rate = sum(payouts) / sum(bets) * 100

# 的中率
hit_rate = wins / total_bets * 100
```

### 評価期間

- 最低100レース以上で評価
- 重賞とそれ以外を分けて分析
- 芝・ダート別に分析

### 改善サイクル

1. 予想を記録
2. 結果を記録
3. 回収率・的中率を計算
4. 外れた理由を分析
5. プロンプト or 特徴量を改善

## 今後の拡張案

### 短期

- [ ] 馬場差データの自動計算
- [ ] 調教データの活用（JRA-VANにある）
- [ ] 血統データの活用

### 中期

- [ ] 機械学習モデルとのアンサンブル
- [ ] オッズから期待値計算
- [ ] 買い目最適化（Kelly基準など）

### 長期

- [ ] リアルタイムオッズ監視
- [ ] 自動投票（PAT連携）
- [ ] Web UI

## 注意事項

### 法的・倫理的

- JRA-VANデータの再配布禁止
- 予想の販売には注意（法規制あり）
- ギャンブル依存症への配慮

### 技術的

- JV-LinkはWindows専用（Linuxでは動かない）
- データ取り込みには数日かかる
- オッズ・票数データは容量が大きい
